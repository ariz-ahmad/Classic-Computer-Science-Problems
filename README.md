# Classical Computer Science Problems
## Kopec, David. "Classic computer science problems in Python." (2019).

Implemetation of classic problems in the field of computer science. Done while reading the book.

### Fibonacci sequence - fib.py
Implementations by successively using Recursion, Memoization, Automatic Memoization, and Using Generator.

### Trivial compression - trivial_compression.py
Compression algorithms have diverse uses; here is a bare-bones implementation of a trivial algorithm.

### Unbreakable encryption - unbreakable_encryption.py
A one-time pad is a way of encrypting a piece of data by combining it with meaningless random dummy data in such a way that the original cannot be reconstituted without access to both the product and the dummy data

### DNA Search - dna_search.py
Genes are commonly represented in computer software as a sequence of the char- acters A, C, G, and T. Each letter represents a nucleotide, and the combination of three nucleotides is called a codon. A linear search goes through every element in a search space, in the order of the original data structure, until what is sought is found or the end of the data structure is reached. 

### Maze Solving - maze.py
Finding a path through a maze is analogous to many common search problems in computer science. 

### Missionaries and Cannibals - missionaries.py
Three missionaries and three can- nibals are on the west bank of a river. They have a canoe that can hold two people, and they all must cross to the east bank of the river. There may never be more cannibals than missionaries on either side of the river, or the can- nibals will eat the missionaries. Further, the canoe must have at least one person on board to cross the river. What sequence of crossings will successfully take the entire party across the river?

### Constraint satisfaction problem - csp.py
Constraints will be defined using a Constraint class. Each Constraint consists of the variables it constrains and a method that checks whether it is satisfied(). The determination of whether a constraint is satisfied is the main logic that goes into defining a specific constraint-satisfaction problem. The default implementation should be overridden. In fact, it must be, because we are defining our Constraint class as an abstract base class. Abstract base classes are not meant to be instantiated. Instead, only their subclasses that override and implement their @abstractmethods are for actual use.

### Australian Map-coloring problem - map_coloring.py
Imagine you have a map of Australia that you want to color by state/territory (which we will collectively call “regions”). No two adjacent regions should share a color. Can you color the regions with just three different colors?

### Eight queens problems - queens.py
The eight queens problem poses the question of how eight queens can be placed on a chessboard without any queen attacking another queen. 

### Word Search - word_search.py
A word search is a grid of letters with hidden words placed along rows, columns, and diagonals. A player of a word-search puzzle attempts to find the hidden words by care- fully scanning through the grid. Finding places to put the words so that they all fit on the grid is a kind of constraint-satisfaction problem. The variables are the words, and the domains are the possible locations of those words.

### Send+More = Money - send_more_money.py
SEND+MORE=MONEY is a cryptarithmetic puzzle, meaning that it is about finding digits that replace letters to make a mathematical statement true. Each letter in the problem represents one digit (0–9). No two letters can represent the same digit. When a letter repeats, it means a digit repeats in the solution.

